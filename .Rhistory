# Instruction to students: You may clear the code in this file and replace it
# with your own.
library(tidyverse)
library(ggforce)
theme_set(theme_void())
# Draw a random chord in a unit circle centred at origin -----------------------
# Coordinates of equilateral triangle
eqtri_df <- tibble(
x    = c(0, sqrt(3) / 2, -sqrt(3) / 2),
y    = c(1, -0.5, -0.5),
xend = c(sqrt(3) / 2, -sqrt(3) / 2, 0),
yend = c(-0.5, -0.5, 1)
)
# Coordinates of random chord
rdmchr_df <- tibble(
x    = 0.93636368,
y    = 0.35103142,
xend = -0.9999991,
yend = -0.001326758
)
# Plot
p <- ggplot() +
ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1), col = "gray50") +
geom_segment(data = eqtri_df, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_segment(data = rdmchr_df, aes(x = x, y = y, xend = xend, yend = yend),
col = "red3") +
coord_equal()
ggsave(p, file = "plot.png", height = 5, width = 7)
# Instruction to students: You may clear the code in this file and replace it
# with your own.
library(tidyverse)
library(ggforce)
theme_set(theme_void())
# Draw a random chord in a unit circle centred at origin -----------------------
# Coordinates of equilateral triangle
eqtri_df <- tibble(
x    = c(0, sqrt(3) / 2, -sqrt(3) / 2),
y    = c(1, -0.5, -0.5),
xend = c(sqrt(3) / 2, -sqrt(3) / 2, 0),
yend = c(-0.5, -0.5, 1)
)
# Coordinates of random chord
rdmchr_df <- tibble(
x    = 0.93636368,
y    = 0.35103142,
xend = -0.9999991,
yend = -0.001326758
)
# Plot
p <- ggplot() +
ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1), col = "gray50") +
geom_segment(data = eqtri_df, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_segment(data = rdmchr_df, aes(x = x, y = y, xend = xend, yend = yend),
col = "red3") +
coord_equal()
ggsave(p, file = "plot.png", height = 5, width = 7)
# Instruction to students: You may clear the code in this file and replace it
# with your own.
library(tidyverse)
library(ggforce)
theme_set(theme_void())
# Draw a random chord in a unit circle centred at origin -----------------------
# Coordinates of equilateral triangle
eqtri_df <- tibble(
x    = c(0, sqrt(3) / 2, -sqrt(3) / 2),
y    = c(1, -0.5, -0.5),
xend = c(sqrt(3) / 2, -sqrt(3) / 2, 0),
yend = c(-0.5, -0.5, 1)
)
# Coordinates of random chord
rdmchr_df <- tibble(
x    = 0.93636368,
y    = 0.35103142,
xend = -0.9999991,
yend = -0.001326758
)
# Plot
ggplot() +
ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1), col = "gray50") +
geom_segment(data = eqtri_df, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_segment(data = rdmchr_df, aes(x = x, y = y, xend = xend, yend = yend),
col = "red3") +
coord_equal()
ggsave(p, file = "plot.png", height = 5, width = 7)
View(eqtri_df)
View(rdmchr_df)
View(p)
library(ggforce)
detach("package:ggplot2", unload = TRUE)
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
install.packages("ggforce")
# Instruction to students: You may clear the code in this file and replace it
# with your own.
library(tidyverse)
library(ggforce)
theme_set(theme_void())
# Draw a random chord in a unit circle centred at origin -----------------------
# Coordinates of equilateral triangle
eqtri_df <- tibble(
x    = c(0, sqrt(3) / 2, -sqrt(3) / 2),
y    = c(1, -0.5, -0.5),
xend = c(sqrt(3) / 2, -sqrt(3) / 2, 0),
yend = c(-0.5, -0.5, 1)
)
# Coordinates of random chord
rdmchr_df <- tibble(
x    = 0.93636368,
y    = 0.35103142,
xend = -0.9999991,
yend = -0.001326758
)
# Plot
p <- ggplot() +
ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1), col = "gray50") +
geom_segment(data = eqtri_df, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_segment(data = rdmchr_df, aes(x = x, y = y, xend = xend, yend = yend),
col = "red3") +
coord_equal()
ggsave(p, file = "plot.png", height = 5, width = 7)
# Method A
angleA1=2*pi*rand(n,1) #generate matrix with angular component uniformly
cx=0
cy=0 #centre of disk
r = input('enter a value for radius : ') #disk radius
cx=0
cy=0 #centre of disk
r = input('enter a value for radius : ') #disk radius
# Instruction to students: You may clear the code in this file and replace it
# with your own.
library(tidyverse)
library(ggforce)
theme_set(theme_void())
# Draw a random chord in a unit circle centred at origin -----------------------
# Coordinates of equilateral triangle
eqtri_df <- tibble(
x    = c(0, sqrt(3) / 2, -sqrt(3) / 2),
y    = c(1, -0.5, -0.5),
xend = c(sqrt(3) / 2, -sqrt(3) / 2, 0),
yend = c(-0.5, -0.5, 1)
)
# Coordinates of random chord
rdmchr_df <- tibble(
x    = 0.93636368,
y    = 0.35103142,
xend = -0.9999991,
yend = -0.001326758
)
# Plot
p <- ggplot() +
ggforce::geom_circle(aes(x0 = 0, y0 = 0, r = 1), col = "gray50") +
geom_segment(data = eqtri_df, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_segment(data = rdmchr_df, aes(x = x, y = y, xend = xend, yend = yend),
col = "red3") +
coord_equal()
ggsave(p, file = "plot.png", height = 5, width = 7)
# Method A
# Centre of disk
cx = 0
cy = 0
r = 5 # disk radius
n = 2 # number of lines
angleA1 = 2*pi*r^2 # generate matrix with angular component uniformly
angleA2 = 2*pi*r^2 # generate matrix with component uniformly
# Chord endpoints calculation as follows
Z <- tibble(
xA1 = cx + r*cos(angleA1),
yA1 = cy + r*sin(angleA1),
xA2 = cx + r*cos(angleA2),
yA2 = cy + r*sin(angleA2)
)
# Calculate midpoints of chord
Mid_chrd <- tibble(
xA0 = ((xA1 + xA2) / 2),
yA0 = ((yA1 + yA2) / 2)
)
# Method A
r2=r/2
angleA=2*pi*runif(n, min=0, max=1)
pC=r*sqrt(runif(n, min=0, max=1))
qC=sqrt((r^2)-(pC^2))
# Method A
r2=r/2
angleA=2*pi*runif(n, min=0, max=1)
pC=r*sqrt(runif(n, min=0, max=1))
qC=sqrt((r^2)-(pC^2))
#Calculate Trig Values
sin_angleC=sin(angleA)
cos_angleC=cos(angleA)
# Method A
r2=r/2
diameter = 10
r = diameter / 2
n = 1
# Method A
angleA=2*pi*runif(n, min=0, max=1)
pA=r*sqrt(runif(n, min=0, max=1))
qA=sqrt((r^2)-(pC^2))
# Method A
diameter = 10
r = diameter / 2
n = 1
angleA=2*pi*runif(n, min=0, max=1)
pA=r*sqrt(runif(n, min=0, max=1))
qA=sqrt((r^2)-(pA^2))
#Calculate Trig Values
sin_angleA=sin(angleA)
cos_angleA=cos(angleA)
xA1=(ax+pA)*((cos_angleA+qA)*(sin_angleA))
# Centre of disk
cx = 0
cy = 0
xA1=(ax+pA)*((cos_angleA+qA)*(sin_angleA))
ax = 0
ay = 0
xA1=(ax+pA)*((cos_angleA+qA)*(sin_angleA))
yA1=(ay+pA)*((sin_angleA-qA)*(cos_angleA))
xA2=(ax+pA)*((cos_angleA-qA)*(sin_angleA))
yA2=(ay+pA)*((sin_angleA+qA)*(cos_angleA))
# Method A
# Centre of disk
ax = 0
ay = 0
diameter = 10
r = diameter / 2
n = 1
angleA=2*pi*runif(n, min=0, max=1)
pA=r*sqrt(runif(n, min=0, max=1))
qA=sqrt((r^2)-(pA^2))
#Calculate Trig Values
sin_angleA=sin(angleA)
cos_angleA=cos(angleA)
#Calculate Chord endpoints
xA1=(ax+pA)*((cos_angleA+qA)*(sin_angleA))
yA1=(ay+pA)*((sin_angleA-qA)*(cos_angleA))
xA2=(ax+pA)*((cos_angleA-qA)*(sin_angleA))
yA2=(ay+pA)*((sin_angleA+qA)*(cos_angleA))
xA0=(xA1+xA2)/2
yA0=(yA1+yA2)/2
lengthA=sqrt((xA1-xA2)^2,(yB1-yB2)^2) #Method A
# Method A
# Centre of disk
ax = 0
ay = 0
diameter = 10
r = diameter / 2
n = 1
angleA = 2*pi*runif(n, min=0, max=1)
pA = r*sqrt(runif(n, min=0, max=1))
qA = sqrt((r^2)-(pA^2))
# Calculate Trig Values
sin_angleA = sin(angleA)
cos_angleA = cos(angleA)
# Calculate Chord endpoints
xA1 = (ax+pA)*((cos_angleA+qA)*(sin_angleA))
yA1 = (ay+pA)*((sin_angleA-qA)*(cos_angleA))
xA2 = (ax+pA)*((cos_angleA-qA)*(sin_angleA))
yA2 = (ay+pA)*((sin_angleA+qA)*(cos_angleA))
# Calculate midpoints of chords
xA0 = (xA1+xA2)/2
yA0 = (yA1+yA2)/2
# Method B
# Centre of disk
ax = 0
ay = 0
diameter = 10
r = diameter / 2
n = 1
angleB = 2*pi*runif(n, min=0, max=1) # Choose angular component uniformly
pB = r*runif(n, min=0, max=1) # Choose radial component uniformly
qB = sqrt((r^2)-(pB^2))
qB2 = 2*sqrt((r^2)-(pB^2)) #Length of chord
# Calculate Trig Values
sin_angleB = sin(angleB)
cos_angleB = cos(angleB)
# Calculate Chord endpoints
xB1 = (ax+pB)*((cos_angleB+qB)*(sin_angleB))
yB1 = (ay+pB)*((sin_angleB-qB)*(cos_angleB))
xB2 = (ax+pB)*((cos_angleB-qB)*(sin_angleB))
yB2 = (ay+pB)*((sin_angleB+qB)*(cos_angleB))
#Calculate midpoints of chords
xB0 = (xB1+xB2)/2
yB0 = (yB1+yB2)/2
# Method C
# Centre of disk
ax = 0
ay = 0
diameter = 10
r = diameter / 2
n = 1
angleC1 = 2*pi*r*runif(n,min=0,max=1) # generate matrix with angular component uniformly
angleC2 = 2*pi*r*runif(n,min=0,max=1) # generate matrix with component uniformly
# Chord endpoints calculation as follows
xC1 = ax + r*cos(angleC1)
yC1 = ay + r*sin(angleC1)
xC2 = ax + r*cos(angleC2)
yC2 = ay + r*sin(angleC2)
# Calculate midpoints of chord
xC0 = (xC1 + xC2) / 2
yC0 = (yC1 + yC2) / 2
# Statistics on chord lengths
lengthSide=r*sqrt(3) #length of triangle side
lengthA=sqrt((xA1-xA2)^2,(yB1-yB2)^2) #Method A
lengthA=sqrt((xA1-xA2)^2+(yB1-yB2)^2) #Method A
lengthA=sqrt((xA1-xA2)^2+(yB1-yB2)^2) #Method A
lengthB=sqrt((xB1-xB2)^2+(yB1-yB2)^2) #Method B
lengthC=sqrt((xC1-xC2)^2+(yC1-yC2^2)) #Method C
lengthA=sqrt((xA1-xA2)^2+(yB1-yB2)^2) #Method A
lengthB=sqrt((xB1-xB2)^2+(yB1-yB2)^2) #Method B
lengthC=sqrt((xC1-xC2)^2+(yC1-yC2^2)) #Method C
lengthA=sqrt((xA1-xA2)^2+(yB1-yB2)^2) #Method A
lengthB=sqrt((xB1-xB2)^2+(yB1-yB2)^2) #Method B
lengthC=sqrt((xC1-xC2)^2+(yC1-yC2)^2) #Method C
probEstA=mean(lengthA>lengthSide)
probEstB=mean(lengthB>lengthSide) #Method B
probEstC=mean(lengthC>lengthSide)
